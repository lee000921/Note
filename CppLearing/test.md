# 第一章 开始
## 1.1 编写一个简单的C++程序
* 函数的定义包含四部分：返回类型、函数名、形参列表、函数体
* 一种类型不仅定义了数据元素的内容，还定义了这类数据上可以进行的运算
### 1.1.1 编译、运行程序
* 在UNIX和Windows系统中，执行完一个程序后，都可以通过echo命令获得其返回值
    * UNIX系统中  $echo \$?
    * Windows系统中 $ echo %ERRORLEVEL%
## 1.2 初始输入输出
* 一个流就是一个字符序列，是从IO设备读出或写入IO设备的。（随着时间的推移，字符是顺序生成或消耗的）
#### 标准输入输出对象
* cin  标准输入（istream）
* cout 标准输出（ostream）
* cerr 标准错误（ostream）
* clog 输出程序运行时的一般性信息（ostream）
#### 一个使用IO库的程序
#### 向流写入数据
* << 运算符接受两个运算对象：左侧的运算对象必须是一个ostream对象。右侧的运算对象是要打印的值。此运算符将给定的值写到给定的ostream对象中。输出运算符的计算结果就是其左侧运算对象
* endl 操纵符  结束当前行，并将与设备关联的缓冲区中的内容刷到设备中。**缓冲刷新操作**可以保证到目前为止程序所产生的所有输出都真正写入输出流中，而不是仅停留在内存中等待写入流
#### 使用标准库中的名字
* 命名空间：帮助我们避免不经意的名字定义冲突，以及使用库中相同名字导致的冲突，标准库定义的所有名字都在std中
* ::  ：作用域运算符
#### 从流读取数据
* 输入运算符(>>)：接受一个istream作为其左侧运算符，从istream中读入数据，并存入给定对象中
#### 完成程序
## 1.3 注释简介
#### C++中注释的种类
* 单行注释
* 界定符对注释
#### 注释界定符不能嵌套
## 1.4 控制流
### 1.4.1 while语句
### 1.4.2 for语句
### 1.4.3 读取数量不定的输入数据
* 当我们使用一个istream对象作为条件时，其效果是检测流的状态。如果流是有效的，即流未遇到错误，那么检测成功。当遇到**文件结束符**，或遇到一个无效输入时（例如读到的值不是一个整数），istream对象的状态会变为无效。处于无效状态的istream对象会使条件变为假
* **Note**：从键盘输入文件结束符
    *  windows：Ctrl+Z
    *  Unix：Ctrl+D
### 1.4.4 if语句
## 1.5 类简介
* 一个类定义了一个类型，以及与其关联的一组操作
### 1.5.1 Sales_item类
### 1.5.2 初始成员函数
* 定义为类的一部分的函数，有时也被称为方法
## 1.6 书店程序
# 第二章 变量和基本类型
## 2.1 基本内置类型
### 2.1.1 算术类型
* 字符类型：
    * wchar_t：可以存放机器最大拓展字符集中任意一个字符
    * char16_t、char32_t：为Unicode字符集服务（unicode用于表示所有自然语言中字符的标准）
#### 带符号类型和无符号类型
* char 和 unsigned char并不一样
### 2.1.2 类型转换
* 当我们赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。例如，8比特的unsigned char可以表示0至255区间里的值，如果我们赋了一个区间以外的值，则实际的结果是该值对256取模后所得的余数
* 当我们赋给带符号类型一个超出它表示范围的值时，结果是**未定义的**。此时程序可能继续工作、可能崩溃、也可能生成垃圾数据。
#### 含有无符号类型的表达式
### 2.1.3 字面值常量
#### 整型和浮点型字面值
* 默认情况下，十进制字面值是带符号数，八进制和十六进制字面值既可能是带符号也可能是无符号的。
* 类型short没有对应的字面值 
#### 字符和字符串字面值
#### 转义序列
* 泛化的转义序列：\x后紧跟1个或多个十六进制数字，或者\后紧跟1个、2个或3个八进制数字，其中数字部分是字符对应的数值
* 如果\后面跟着的八进制数字超过三个，只有前三个数字与\构成转义序列
#### 指定字面值的类型
* 字符和字符串字面值（前缀）：
    * u：Unicode16字符 char16_t
    * U：Unicode32字符 char32_t
    * L：宽字符 wchar_t
    * u8：UTF-8 char
* 整形字符值（后缀）：
    * u/U：unsigned
    * l/L：long
    * ll/LL：long long
* 浮点型字面值（后缀）：
    * f/F：float
    * l/L：long double
#### 布尔字面值和指针字面值
* true/false
* nullptr  
## 2.2 变量
具名的、可供程序操作的存储空间
### 2.2.1 变量定义
* 对象：具有某种数据类型的内存空间
#### 初始值
* 在同一条定义语句中，可以用先定义的变量值去初始化后定义的其他变量
* 初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来替代
#### 列表初始化：用花括号来初始化变量
* 如果我们使用列表初始化且初始值存在丢失信息的风险，则编译器将报错
#### 默认初始化
* 如果是内置类型的变量未被显式初始化，它的值由定义的位置决定。定义于任何函数体之外的变量将被初始化为0.定义在函数体内部的内置类型变量将**不被初始化**。一个未被初始化的内置类型变量的值是**未定义的**，如果试图拷贝或以其他形式访问此类值将引发错误
* 每个类各自决定其初始化对象的方式。而且，是否允许不经初始化就定义对象也由类自己决定。如果类允许这种行为，它将决定对象的初始值到底是什么
### 2.2.2 变量声明和定义的关系
* 如果想声明一个变量而非定义它，就在变量名面前添加关键字**extern**，而且不要显示地初始化变量
* 在函数体内部，如果试图初始化一个由extern关键字标记的变量，将引发错误
* Note：C++是一种静态类型语言，其含义是在编译阶段检查类型。
### 2.2.3 标识符
* 用户自定义的标识符中不能连续出现两个下划线，也不能以下划线紧连大写字母的开头
* 定义在函数体外的标识符不能以下划线开头
#### 变量命名规范
* 变量名一般用小写字母
* 用户自定义的类名一般以大写字母开头
### 2.2.4 名字的作用域
#### 嵌套的作用域
* 当作用域操作符的左侧为空时，向全局作用域发出请求获取作用域操作符右侧名字对应的变量
## 2.3 复合类型
* 基于其他类型定义的类型
### 2.3.1 引用
* 为对象起了另外一个名字
* 引用必须被初始化
#### 引用即别名
* 因为引用本身不是一个对象，所以不能定义引用的引用
#### 引用的定义
* 引用类型的初始值必须是一个对象
### 2.3.2 指针
* 指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象
* 指针无须在定义时赋初值
#### 获取对象的地址
* 引用不是对象，没有实际地址，所以不能定义指向引用的指针
#### 指针值
* 四种状态
    * 指向一个对象
    * 指向紧邻对象所占空间的下一个位置
    * 空指针，指针没有指向任何对象
    * 无效指针，上述情况之外的其他值
* 试图拷贝或以其他方式访问无效指针的值都将引发错误
#### 利用指针访问对象
* 解引用操作仅适用于那些确实指向了某个对象的有效指针
#### 空指针
* 预处理器：运行于编译过程之前的一段程序
#### 赋值和指针
#### 其他指针操作
* 只要指针拥有一个合法值，就能将它用在条件表达式中，如果指针的值是0，条件取false，任何非0指针对应的条件值都是true
#### void*指针
* 可用于存放任意对象的地址
* 不能直接操作void*指针所指的对象
### 理解复合类型的声明
#### 定义多个变量
#### 指向指针的指针
#### 指向指针的引用