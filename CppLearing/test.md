# 第一章 开始
## 1.1 编写一个简单的C++程序
* 函数的定义包含四部分：返回类型、函数名、形参列表、函数体
* 一种类型不仅定义了数据元素的内容，还定义了这类数据上可以进行的运算
### 1.1.1 编译、运行程序
* 在UNIX和Windows系统中，执行完一个程序后，都可以通过echo命令获得其返回值
    * UNIX系统中  $echo \$?
    * Windows系统中 $ echo %ERRORLEVEL%
## 1.2 初始输入输出
* 一个流就是一个字符序列，是从IO设备读出或写入IO设备的。（随着时间的推移，字符是顺序生成或消耗的）
#### 标准输入输出对象
* cin  标准输入（istream）
* cout 标准输出（ostream）
* cerr 标准错误（ostream）
* clog 输出程序运行时的一般性信息（ostream）
#### 一个使用IO库的程序
#### 向流写入数据
* << 运算符接受两个运算对象：左侧的运算对象必须是一个ostream对象。右侧的运算对象是要打印的值。此运算符将给定的值写到给定的ostream对象中。输出运算符的计算结果就是其左侧运算对象
* endl 操纵符  结束当前行，并将与设备关联的缓冲区中的内容刷到设备中。**缓冲刷新操作**可以保证到目前为止程序所产生的所有输出都真正写入输出流中，而不是仅停留在内存中等待写入流
#### 使用标准库中的名字
* 命名空间：帮助我们避免不经意的名字定义冲突，以及使用库中相同名字导致的冲突，标准库定义的所有名字都在std中
* ::  ：作用域运算符
#### 从流读取数据
* 输入运算符(>>)：接受一个istream作为其左侧运算符，从istream中读入数据，并存入给定对象中
#### 完成程序
## 1.3 注释简介
#### C++中注释的种类
* 单行注释
* 界定符对注释
#### 注释界定符不能嵌套
## 1.4 控制流
### 1.4.1 while语句
### 1.4.2 for语句
### 1.4.3 读取数量不定的输入数据
* 当我们使用一个istream对象作为条件时，其效果是检测流的状态。如果流是有效的，即流未遇到错误，那么检测成功。当遇到**文件结束符**，或遇到一个无效输入时（例如读到的值不是一个整数），istream对象的状态会变为无效。处于无效状态的istream对象会使条件变为假
* **Note**：从键盘输入文件结束符
    *  windows：Ctrl+Z
    *  Unix：Ctrl+D
### 1.4.4 if语句
## 1.5 类简介
* 一个类定义了一个类型，以及与其关联的一组操作
### 1.5.1 Sales_item类
### 1.5.2 初始成员函数
* 定义为类的一部分的函数，有时也被称为方法
## 1.6 书店程序
# 第二章 变量和基本类型
## 2.1 基本内置类型
### 2.1.1 算术类型
* 字符类型：
    * wchar_t：可以存放机器最大拓展字符集中任意一个字符
    * char16_t、char32_t：为Unicode字符集服务（unicode用于表示所有自然语言中字符的标准）
#### 带符号类型和无符号类型
* char 和 unsigned char并不一样
### 2.1.2 类型转换
* 当我们赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。例如，8比特的unsigned char可以表示0至255区间里的值，如果我们赋了一个区间以外的值，则实际的结果是该值对256取模后所得的余数
* 当我们赋给带符号类型一个超出它表示范围的值时，结果是**未定义的**。此时程序可能继续工作、可能崩溃、也可能生成垃圾数据。
#### 含有无符号类型的表达式
### 2.1.3 字面值常量
#### 整型和浮点型字面值
* 默认情况下，十进制字面值是带符号数，八进制和十六进制字面值既可能是带符号也可能是无符号的。
* 类型short没有对应的字面值 
#### 字符和字符串字面值
#### 转义序列
* 泛化的转义序列：\x后紧跟1个或多个十六进制数字，或者\后紧跟1个、2个或3个八进制数字，其中数字部分是字符对应的数值
* 如果\后面跟着的八进制数字超过三个，只有前三个数字与\构成转义序列
#### 指定字面值的类型
* 字符和字符串字面值（前缀）：
    * u：Unicode16字符 char16_t
    * U：Unicode32字符 char32_t
    * L：宽字符 wchar_t
    * u8：UTF-8 char
* 整形字符值（后缀）：
    * u/U：unsigned
    * l/L：long
    * ll/LL：long long
* 浮点型字面值（后缀）：
    * f/F：float
    * l/L：long double
#### 布尔字面值和指针字面值
* true/false
* nullptr  
## 2.2 变量
具名的、可供程序操作的存储空间
### 2.2.1 变量定义
* 对象：具有某种数据类型的内存空间
#### 初始值
* 在同一条定义语句中，可以用先定义的变量值去初始化后定义的其他变量
* 初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来替代
#### 列表初始化：用花括号来初始化变量
* 如果我们使用列表初始化且初始值存在丢失信息的风险，则编译器将报错
#### 默认初始化
* 如果是内置类型的变量未被显式初始化，它的值由定义的位置决定。定义于任何函数体之外的变量将被初始化为0.定义在函数体内部的内置类型变量将**不被初始化**。一个未被初始化的内置类型变量的值是**未定义的**，如果试图拷贝或以其他形式访问此类值将引发错误
* 每个类各自决定其初始化对象的方式。而且，是否允许不经初始化就定义对象也由类自己决定。如果类允许这种行为，它将决定对象的初始值到底是什么
### 2.2.2 变量声明和定义的关系
* 如果想声明一个变量而非定义它，就在变量名面前添加关键字**extern**，而且不要显示地初始化变量
* 在函数体内部，如果试图初始化一个由extern关键字标记的变量，将引发错误
* Note：C++是一种静态类型语言，其含义是在编译阶段检查类型。
### 2.2.3 标识符
* 用户自定义的标识符中不能连续出现两个下划线，也不能以下划线紧连大写字母的开头
* 定义在函数体外的标识符不能以下划线开头
#### 变量命名规范
* 变量名一般用小写字母
* 用户自定义的类名一般以大写字母开头
### 2.2.4 名字的作用域
#### 嵌套的作用域
* 当作用域操作符的左侧为空时，向全局作用域发出请求获取作用域操作符右侧名字对应的变量
## 2.3 复合类型
* 基于其他类型定义的类型
### 2.3.1 引用
* 为对象起了另外一个名字
* 引用必须被初始化
#### 引用即别名
* 因为引用本身不是一个对象，所以不能定义引用的引用
#### 引用的定义
* 引用类型的初始值必须是一个对象
### 2.3.2 指针
* 指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象
* 指针无须在定义时赋初值
#### 获取对象的地址
* 引用不是对象，没有实际地址，所以不能定义指向引用的指针
#### 指针值
* 四种状态
    * 指向一个对象
    * 指向紧邻对象所占空间的下一个位置
    * 空指针，指针没有指向任何对象
    * 无效指针，上述情况之外的其他值
* 试图拷贝或以其他方式访问无效指针的值都将引发错误
#### 利用指针访问对象
* 解引用操作仅适用于那些确实指向了某个对象的有效指针
#### 空指针
* 预处理器：运行于编译过程之前的一段程序
#### 赋值和指针
#### 其他指针操作
* 只要指针拥有一个合法值，就能将它用在条件表达式中，如果指针的值是0，条件取false，任何非0指针对应的条件值都是true
#### void*指针
* 可用于存放任意对象的地址
* 不能直接操作void*指针所指的对象
### 理解复合类型的声明
#### 定义多个变量
#### 指向指针的指针
#### 指向指针的引用
## 2.4 const限定符
* 因为const对象一旦创建后其值就不能再改变，所以const对象必须初始化
#### 初始化和const
#### 默认状态下，const对象仅在文件中有效
* 当多个文件中出现了同名的const变量时，其实等同于在不同文件中分别定义了独立的变量
* 如果想在多个文件之间共享const对象，必须在变量的定义之前添加extern关键字
### 2.4.1 const的引用
* 对常量的引用不能被用作修改它所绑定的对象
#### 初始化和对const的引用
* 在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可
#### 对const的引用可能引用一个并非const的对象
### 2.4.2 指针和const
* 指向常量的指针不能用于改变其所指对象的值
* 允许一个指向常量的指针指向一个非常量的对象
#### const指针
* 指针本身是一个常量并不意味着不能通过指针修改其所指对象的值，能否这样做完全依赖于所指对象的类型
### 2.4.3 顶层const
* 顶层const：指针本身是个常量
* 底层const：指针所指的对象是一个常量
* 指针类型既可以是顶层const也可以是底层const
### 2.4.4 constexpr和常量表达式
* 常量表达式：值不会改变并且在编译过程就能得到计算结果的表达式
#### constexpr变量
* 一般来说，如果你认定变量是一个常量表达式，那就把它声明称constexpr类型
* 声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化
#### 字面值类型
* 算术类型、引用和指针都属于字面值类型
* IO库、string类型不属于字面值类型，不能被定义成constexpr
* 一个constexpr指针的初始值必须是nullptr或0，或者是存储于**某个固定地址中的对象** 
* 函数体内定义的变量一般来说并非存放在固定地址中，因此constexpr指针不能指向这样的变量。相反的，定义于所用函数体之外的对象其地址固定不变，能用来初始化constexpr指针
* 允许函数定义一类有效范围超出函数本身的变量，这类变量和定义在函数体之外的变量一样也有固定地址。因此constexpr引用能绑定在这样的变量上，constexpr指针也能指向这样的变量
#### 指针和constexpr
* 限定符constexpr只对指针有效，与指针所指的对象无关
```C++{.line-numbers}
const int *p = nullptr;//p是一个指向整型常量的指针
constexpr int* q = nullptr;//q是一个指向整型的常量指针
```
* constexpr把它所定义的对象置为了顶层const
## 2.5 处理类型
### 2.5.1 类型别名
* 关键字typedef
* 别名声明：把等号左侧的名字规定成等号右侧类型的别名
    ```C++
    using SI = sales_item;
    ```
#### 指针、常量和类型别名
* Note： const pstring 是指向char的常量指针，而非指向常量字符的指针
    ```C++ {.line-numbers}
    typedef char *pstring;
    const pstring cstr = 0;
    const pstring *ps;
    ```
### 2.5.2 auto类型说明符
* auto定义的变量必须有初始值
* 也可以在一条语句中声明多个变量，但该语句中的所有变量的初始基本数据类型必须一样
#### 复合类型、常量和auto
* 编译器会适当的改变结果类型使其更符合初始化规则
* 用引用类型初始化auto变量时，会以引用对象的类型作为auto的类型
* auto一般会忽略掉顶层const，保留底层const。如果希望推断出的auto类型是一个顶层const，需要明确指出
```C++{.numbers}
const auto f = ci;
```
* 设置一个类型为auto的引用时，初始值中的顶层常量属性仍然保留。如果我们给初始值绑定一个引用，则此时的常量就不是顶层常量了。
### 2.5.3 decltype 指示符
* 选择并返回操作数的数据类型，编译器分析表达式并得到他的类型，却不实际计算表达式的值
* 如果decltype使用的表达式是一个变量，则返回该变量的类型（包括顶层const和引用在内）
#### decltype和引用
* 如果表达式计算结果是引用，必须初始化
* 如果表达式的内容是解引用操作，则decltype将得到引用类型
* 对于decltype所用的表达式来说，如果变量名加上了一层括号，则得到的类型与不加括号时会有不同。具体表现为：decltype((variable))的结果永远是引用，而decltype(variable)的结果只有当variable本身就是一个引用时才是引用
* 变量是一种可以作为赋值语句左值的特殊表达式
## 2.6 自定义数据结构
### 2.6.1 定义Sales_data类型
### 2.6.2 使用Sales_data类
### 2.6.3 编写自己的头文件
* 头文件中通常包含那些只能被定义一次的实体，如类、const、和constexpr变量
* 头文件一旦改变，相关的源文件必须重新编译以获取更新过的声明
#### 预处理器概述
* 头文件保护符
* 预处理变量无视C++语言中关于作用域的规则
* 一般把预处理变量的名字全部大写
# 第三章 字符串、向量和数组
## 3.1 命名空间的using声明
### 每个名字都需要独立的using声明
### 头文件不应包含using声明
## 3.2 标准库类型string
* C++标准一方面对库类型所提供的操作做出了详细规定，另一方面也对库的实现者做出一些性能上的需求。因此，标准库类型对于一般应用场合来说有足够的效率。
### 3.2.1 定义和初始化string对象
```C++
string s4(10,'c');//s4内容为cccccccccc
```
#### 直接初始化和拷贝初始化
* 使用等号初始化变量，实际上执行的是拷贝初始化；不使用等号则是直接初始化
* 当初始值只有一个时，使用直接初始化或拷贝初始化都行。初始化要用到的值有多个，一般来说只能使用直接初始化的方式
### 3.2.2 string对象上的操作
* <,<=,>,>= 对字母的大小写是敏感的
#### 读写string对象
* 读标准输入的时候，string对象会自动忽略开头的空白（空格符、换行符、制表符等），从第一个真正的字符开始读起，直到遇见下一处空白为止。
#### 读取未知数量的string对象
```C++
while(cin >> word)//在读取时检测流的情况
```
#### 使用getline读取一整行
* 直到遇到换行符为止，**此时换行符也被读进来了**
* 读进来的内容需要存到string对象中 **不存换行符**
* getline也会返回它的流参数
#### string的empty和size操作
#### string::size_type类型
* 它是一个无符号类型的值，而且能足够存放下任何string对象的大小
* 如果一条表达式中已经有了size（）函数就不要再使用int了，这样可以避免混用int和unsigned int可能带来的问题
#### 比较string对象
#### 为string对象赋值
#### 两个string对象相加
* 连接两string
* 支持 +=
#### 字面值和string对象相加
* 当把string对象和字符字面值及字符串字面值混在一条语句中使用时，必须确保每个加法运算符（+）的两侧的运算对象至少有一个是string
* C++语言中的字符串字面值并不是标准库类型string的对象
### 3.2.3 处理string对象中的字符
* cctype头文件 定义了一组标准库文件 判断每个字符的特性
#### 处理每个字符？使用基于范围的for语句
* 范围for 遍历给定序列中的每个元素
```C++
for(declaration : expression)
    statement;
```
* expression部分表示一个序列，declaration表示的是一个属于序列中的变量
#### 使用范围for语句改变字符串中的字符
* 如果想要改变string对象中字符的值，必须把循环变量定义成引用类型
#### 只处理一部分字符？
* 两种方式：下标 或 迭代器
#### 使用下标进行迭代
* 一种简便易行的方式：总是设下标的类型为string::size_type，因为此类型是无符号数，可以确保下标不会小于0，此时只需要保证下标小于size()的值就可以了
#### 使用下标执行随机访问
## 3.3 标准库类型vector
* 编译器根据模板创建类或函数的过程称为**实例化**
* 引用不是对象，不存在包含引用的vector
### 3.3.1 定义和初始化vector对象
#### 列表初始化vector对象
* 初始化例外情况
    * 使用拷贝初始化时，只能提供一个初始值
    * 如果提供的是一个类内初始值，则只能使用拷贝初始化或使用花括号的形式初始化
    * 如果提供的是初始元素值的列表，则只能把初始值都放在花括号里进行列表初始化，而不能放在圆括号里
    ```C++
    vector<string> v1{"a","an","the"};
    ```
#### 创建指定数量的元素
#### 值初始化
* 两个要求
    * 有些类要求必须明确地提供初始值，如果vector对象中元素的类型不支持默认初始化，无法提供初始的元素值
    * 如果只提供了元素的数量而没有设定初始值，只能使用直接初始化
#### 列表初始值还是元素数量？
* 如果用了花括号，可以表述成我们想列表初始化该vector对象，初始化过程中会尽可能把花括号内的值当成是元素初始值的列表来处理，只有实在无法执行列表初始化时才会考虑其他初始化方式，才会用这样的值来**构造**vector对象了
### 3.3.2 向vector对象中添加元素
* 直接初始化的方式适用于三种情况：
    * 初始值已知且数量较少
    * 初始值是另一个vector对象的副本
    * 所有元素的初始值一样
#### 向vector对象添加元素蕴含的编程假定
* 如果循环体内部包含有向vector对象添加元素的语句，则不能使用范围for循环
* 范围for语句体内不应改变其所遍历序列的大小
### 3.3.3 其他vector操作
* 要使用size_type，需首先指定它是由哪种类型定义的
    * vector<int>::size_type
#### 计算vector内对象的索引
#### 不能用下标形式添加元素
* vector对象以及string对象的下标运算符可用于访问已存在的元素，而不能用于添加元素
* 确保下标合法的一种有效手段就是尽可能使用范围for语句
## 3.4 迭代器介绍
* 有效的迭代器或者指向某个元素，或者指向容器中尾元素的下一位置
### 3.4.1 使用迭代器
* end成员返回指向容器尾元素的下一位置的迭代器
#### 迭代器运算符
#### 将迭代器从一个元素移动到另外一个元素
* 因为end返回的迭代器并不实际指示某个元素，所以不能对其进行递增或解引用的操作
#### 迭代器类型
* iterator | const_iterator
* 如果vector对象或string对象是一个常量，只能使用const_iterator
#### begin和end运算符
* cbegin、cend不论vector对象本身是否为常量，返回值都是const_iterator
#### 结合解引用和成员访问操作
#### 某些对vector对象的操作会使迭代器失效
* 任何一种可能改变vector对象容量的操作，都会使vector对象的迭代器失效
* 但凡是使用了迭代器的循环体，都不要向迭代器所属的容器添加元素
### 3.4.2 迭代器运算
#### 迭代器的算术运算 
* 迭代器相减结果类型为名为difference_type的带符号整数
#### 使用迭代器计算
## 3.5 数组
### 3.5.1 定义和初始化内置数组
* 数组的维度必须是一个常量表达式
* 定义数组时必须指定数组的类型，不允许用auto关键字由auto关键字由初始值列表推断类型
* 不存在引用的数组
#### 显式初始化数组元素
* 如果维度比提供的初始值数量大，则用提供的初始值初始化靠前的元素，剩下的元素被初始化成默认值
#### 字符数组的特殊性
* 有一种额外的初始化形式，可以用字符串字面值对数组进行初始化，要注意字符串字面值结尾处还有一个空字符
#### 不允许拷贝和赋值
#### 理解复杂的数组声明
```C++
int (*Parray)[10] = &arr;//Parray指向一个含有10个整数的数组
int (&arrRef)[10] = arr;//arrRef引用一个含有10个整数的数组
```
### 3.5.2 访问数组元素
* 在使用数组下标的时候，通常将其定义为size_t类型（机器相关的无符号类型，被设计的足够大以便能表示内存中任意对象的大小） 在cstddef文件中定义
#### 检查下标的值
### 3.5.3 指针和数组
* 使用数组的时候，编译器一般把它转换成指针
* 当使用一个数组作为一个auto变量的初始值时，推断得到的类型是指针而不是数组
* 当使用decltyoe关键字时，返回的类型是数组
#### 指针也是迭代器
#### 标准库函数begin和end
* 两个函数，数组作为参数传入，定义在iterator头文件中
#### 指针运算
* 两个指针相减的结果类型是一种名为ptrdiff_t的标准库类型，带符号
* 如果p是空指针，允许给p加上或减去一个值为0的整型常量表达式。
* 两个空指针也允许彼此相减，结果为0
#### 解引用和指针运算的交互
#### 下标和指针
* 标准库类型限定使用的下标必须是无符号类型，但内置的下标没有这个要求（不是无符号类型），可以处理负值
### 3.5.4 C风格字符串
* C风格字符串不是一种类型，而是为了表达和使用字符串而形成的一种约定俗成的写法
#### C标准String函数
#### 比较字符串
#### 目标字符串的大小由调用者指定
### 3.5.5 与旧代码的接口
#### 混用string对象和C风格字符串
* 任何出现字符串字面值的地方都可以用以空字符结束的字符数组来替代
#### 使用数组初始化vector对象
```C++
int int_arr[] = {0,1,2,3,4,5};
vector<int> ivec(begin(int_arr),end(int_arr));
vector<int> subVec(int_arr + 1,int_arr + 4);
```
## 3.6 多维数组
#### 多维数组的初始化
#### 多维数组的下标引用
#### 使用范围for语句处理多维数组
* 要使用范围for语句处理多维数组，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型
#### 指针和多维数组
* 多维数组实质上是数组的数组
#### 类型别名简化多维数组的指针
# 第4章 表达式
## 4.1 基础
### 4.1.1 基本概念
#### 组合运算符和运算对象
#### 运算对象转换
* 小整数类型通常会被提升成较大的整数类型
#### 重载运算符
* 重载运算符时，其包括运算对象的类型和返回值的类型，都是由该运算符定义的；但是运算对象的个数、运算符的优先级和结合律都是无法改变的
#### 左值和右值
* 当一个对象被用作右值的时候，用的是对象的值（内容），当对象被用作左值的时候，用的是对象的身份（在内存中的位置）
* 一个重要的原则：在需要右值的地方可以用左值来代替，但是不能把右值当成左值使用
* 使用关键字decltype时候，左值和右值也会有不同。如果表达式的求值结果是左值，decltype得到一个引用类型。
### 4.1.2 优先级与结合律
#### 括号无视优先级与结合律
#### 优先级与结合律有何影响
### 4.1.3 求值顺序
#### 求值顺序、优先级、结合律
* 运算对象的求值顺序与优先级和结合律无关
* 拿不准运算顺序的时候，最好用括号来强制让表达式的组合关系符合程序逻辑的要求
* 如果改变了某个运算对象的值，在表达式的其它地方不要再使用这个运算对象
## 4.2 算术运算符
 ```C++
 bool b = true;
 bool b2 = -b;//b2依然为true
 ```
* C++11规定商一律向0取整
* 除了-m导致溢出的特殊情况，其他时候(-m)/n和m/(-n)都等于-(m/n)，m%(-n)等于m%n，(-m)%n等于-(m%n)
## 4.3 逻辑和关系运算符
#### 逻辑与和逻辑或运算符
* 短路求值
    * 对于逻辑与运算符来说，当且仅当左侧运算对象为真时才对右侧运算对象求值
    * 对于逻辑或运算符来说，当且仅当左侧运算对象为假时才对右侧运算对象求值
* 声明成引用类型可以避免对元素的拷贝
#### 逻辑非运算符
#### 关系运算符
#### 相等性测试与布尔字面值
* 进行比较运算时除非比较的对象是布尔类型，否则不要使用布尔字面值true和false作为运算对象
## 4.4 赋值运算符
* 在使用初始值列表作为赋值语句的右侧运算对象时，如果左侧运算对象是内置类型，那么初始值参数列表最多只能包含一个值，而且该值即使转换的话其所占空间也不应该大于目标类型的空间
#### 赋值运算满足右结合律
```C++
int ival,jval;
ival = jval = 0;//正确，都被赋值为0
```
#### 赋值运算优先级较低
* 赋值运算符的优先级低于关系运算符的优先级
#### 切勿混淆相等运算符和赋值运算符
#### 复合赋值运算符
## 4.5 递增和递减运算符
* 必须作用于左值运算对象。前置版本将对象本身作为左值返回，后置版本则将对象原始值的副本作为右值返回
* 除非必须，否则不用递增递减运算符的后置版本
#### 在一条语句中混用解引用和递增运算符
#### 运算对象可按任意顺序求值
## 4.6 成员访问运算符
## 4.7 条件运算符
* 当条件运算符的两个表达式都是左值或者能转换成同一种左值类型时，运算的结果是左值；否则运算的结果是右值
#### 嵌套条件运算符
* 随着条件运算嵌套层数的增加，代码的可读性急剧下降。最好别超过两到三层
#### 在输出表达式中使用条件运算符
## 4.8 位运算符
* 关于符号位如何处理没有明确的规定，所以强烈建议仅将位运算符用于处理无符号类型
#### 移位运算符



