# 第一章 开始
## 1.1 编写一个简单的C++程序
* 函数的定义包含四部分：返回类型、函数名、形参列表、函数体
* 一种类型不仅定义了数据元素的内容，还定义了这类数据上可以进行的运算
### 1.1.1 编译、运行程序
* 在UNIX和Windows系统中，执行完一个程序后，都可以通过echo命令获得其返回值
    * UNIX系统中  $echo \$?
    * Windows系统中 $ echo %ERRORLEVEL%
## 1.2 初始输入输出
* 一个流就是一个字符序列，是从IO设备读出或写入IO设备的。（随着时间的推移，字符是顺序生成或消耗的）
#### 标准输入输出对象
* cin  标准输入（istream）
* cout 标准输出（ostream）
* cerr 标准错误（ostream）
* clog 输出程序运行时的一般性信息（ostream）
#### 一个使用IO库的程序
#### 向流写入数据
* << 运算符接受两个运算对象：左侧的运算对象必须是一个ostream对象。右侧的运算对象是要打印的值。此运算符将给定的值写到给定的ostream对象中。输出运算符的计算结果就是其左侧运算对象
* endl 操纵符  结束当前行，并将与设备关联的缓冲区中的内容刷到设备中。**缓冲刷新操作**可以保证到目前为止程序所产生的所有输出都真正写入输出流中，而不是仅停留在内存中等待写入流
#### 使用标准库中的名字
* 命名空间：帮助我们避免不经意的名字定义冲突，以及使用库中相同名字导致的冲突，标准库定义的所有名字都在std中
* ::  ：作用域运算符
#### 从流读取数据
* 输入运算符(>>)：接受一个istream作为其左侧运算符，从istream中读入数据，并存入给定对象中
#### 完成程序
## 1.3 注释简介
#### C++中注释的种类
* 单行注释
* 界定符对注释
#### 注释界定符不能嵌套
## 1.4 控制流
### 1.4.1 while语句
### 1.4.2 for语句
### 1.4.3 读取数量不定的输入数据
* 当我们使用一个istream对象作为条件时，其效果是检测流的状态。如果流是有效的，即流未遇到错误，那么检测成功。当遇到**文件结束符**，或遇到一个无效输入时（例如读到的值不是一个整数），istream对象的状态会变为无效。处于无效状态的istream对象会使条件变为假
* **Note**：从键盘输入文件结束符
    *  windows：Ctrl+Z
    *  Unix：Ctrl+D
### 1.4.4 if语句
## 1.5 类简介
* 一个类定义了一个类型，以及与其关联的一组操作
### 1.5.1 Sales_item类
### 1.5.2 初始成员函数
* 定义为类的一部分的函数，有时也被称为方法
## 1.6 书店程序
# 第二章 变量和基本类型
## 2.1 基本内置类型
### 2.1.1 算术类型
* 字符类型：
    * wchar_t：可以存放机器最大拓展字符集中任意一个字符
    * char16_t、char32_t：为Unicode字符集服务（unicode用于表示所有自然语言中字符的标准）
#### 带符号类型和无符号类型
* char 和 unsigned char并不一样
### 2.1.2 类型转换
* 当我们赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。例如，8比特的unsigned char可以表示0至255区间里的值，如果我们赋了一个区间以外的值，则实际的结果是该值对256取模后所得的余数
* 当我们赋给带符号类型一个超出它表示范围的值时，结果是**未定义的**。此时程序可能继续工作、可能崩溃、也可能生成垃圾数据。
#### 含有无符号类型的表达式
### 2.1.3 字面值常量
#### 整型和浮点型字面值
* 默认情况下，十进制字面值是带符号数，八进制和十六进制字面值既可能是带符号也可能是无符号的。
* 类型short没有对应的字面值 
#### 字符和字符串字面值
#### 转义序列
* 泛化的转义序列：\x后紧跟1个或多个十六进制数字，或者\后紧跟1个、2个或3个八进制数字，其中数字部分是字符对应的数值
* 如果\后面跟着的八进制数字超过三个，只有前三个数字与\构成转义序列
#### 指定字面值的类型
* 字符和字符串字面值（前缀）：
    * u：Unicode16字符 char16_t
    * U：Unicode32字符 char32_t
    * L：宽字符 wchar_t
    * u8：UTF-8 char
* 整形字符值（后缀）：
    * u/U：unsigned
    * l/L：long
    * ll/LL：long long
* 浮点型字面值（后缀）：
    * f/F：float
    * l/L：long double
#### 布尔字面值和指针字面值
* true/false
* nullptr  
## 2.2 变量
具名的、可供程序操作的存储空间
### 2.2.1 变量定义
* 对象：具有某种数据类型的内存空间
#### 初始值
* 在同一条定义语句中，可以用先定义的变量值去初始化后定义的其他变量
* 初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来替代
#### 列表初始化：用花括号来初始化变量
* 如果我们使用列表初始化且初始值存在丢失信息的风险，则编译器将报错
#### 默认初始化
* 如果是内置类型的变量未被显式初始化，它的值由定义的位置决定。定义于任何函数体之外的变量将被初始化为0.定义在函数体内部的内置类型变量将**不被初始化**。一个未被初始化的内置类型变量的值是**未定义的**，如果试图拷贝或以其他形式访问此类值将引发错误
* 每个类各自决定其初始化对象的方式。而且，是否允许不经初始化就定义对象也由类自己决定。如果类允许这种行为，它将决定对象的初始值到底是什么
### 2.2.2 变量声明和定义的关系
* 如果想声明一个变量而非定义它，就在变量名面前添加关键字**extern**，而且不要显示地初始化变量
* 在函数体内部，如果试图初始化一个由extern关键字标记的变量，将引发错误
* Note：C++是一种静态类型语言，其含义是在编译阶段检查类型。
### 2.2.3 标识符
* 用户自定义的标识符中不能连续出现两个下划线，也不能以下划线紧连大写字母的开头
* 定义在函数体外的标识符不能以下划线开头
#### 变量命名规范
* 变量名一般用小写字母
* 用户自定义的类名一般以大写字母开头
### 2.2.4 名字的作用域
#### 嵌套的作用域
* 当作用域操作符的左侧为空时，向全局作用域发出请求获取作用域操作符右侧名字对应的变量
## 2.3 复合类型
* 基于其他类型定义的类型
### 2.3.1 引用
* 为对象起了另外一个名字
* 引用必须被初始化
#### 引用即别名
* 因为引用本身不是一个对象，所以不能定义引用的引用
#### 引用的定义
* 引用类型的初始值必须是一个对象
### 2.3.2 指针
* 指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象
* 指针无须在定义时赋初值
#### 获取对象的地址
* 引用不是对象，没有实际地址，所以不能定义指向引用的指针
#### 指针值
* 四种状态
    * 指向一个对象
    * 指向紧邻对象所占空间的下一个位置
    * 空指针，指针没有指向任何对象
    * 无效指针，上述情况之外的其他值
* 试图拷贝或以其他方式访问无效指针的值都将引发错误
#### 利用指针访问对象
* 解引用操作仅适用于那些确实指向了某个对象的有效指针
#### 空指针
* 预处理器：运行于编译过程之前的一段程序
#### 赋值和指针
#### 其他指针操作
* 只要指针拥有一个合法值，就能将它用在条件表达式中，如果指针的值是0，条件取false，任何非0指针对应的条件值都是true
#### void*指针
* 可用于存放任意对象的地址
* 不能直接操作void*指针所指的对象
### 理解复合类型的声明
#### 定义多个变量
#### 指向指针的指针
#### 指向指针的引用
## 2.4 const限定符
* 因为const对象一旦创建后其值就不能再改变，所以const对象必须初始化
#### 初始化和const
#### 默认状态下，const对象仅在文件中有效
* 当多个文件中出现了同名的const变量时，其实等同于在不同文件中分别定义了独立的变量
* 如果想在多个文件之间共享const对象，必须在变量的定义之前添加extern关键字
### 2.4.1 const的引用
* 对常量的引用不能被用作修改它所绑定的对象
#### 初始化和对const的引用
* 在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可
#### 对const的引用可能引用一个并非const的对象
### 2.4.2 指针和const
* 指向常量的指针不能用于改变其所指对象的值
* 允许一个指向常量的指针指向一个非常量的对象
#### const指针
* 指针本身是一个常量并不意味着不能通过指针修改其所指对象的值，能否这样做完全依赖于所指对象的类型
### 2.4.3 顶层const
* 顶层const：指针本身是个常量
* 底层const：指针所指的对象是一个常量
* 指针类型既可以是顶层const也可以是底层const
### 2.4.4 constexpr和常量表达式
* 常量表达式：值不会改变并且在编译过程就能得到计算结果的表达式
#### constexpr变量
* 一般来说，如果你认定变量是一个常量表达式，那就把它声明称constexpr类型
* 声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化
#### 字面值类型
* 算术类型、引用和指针都属于字面值类型
* IO库、string类型不属于字面值类型，不能被定义成constexpr
* 一个constexpr指针的初始值必须是nullptr或0，或者是存储于**某个固定地址中的对象** 
* 函数体内定义的变量一般来说并非存放在固定地址中，因此constexpr指针不能指向这样的变量。相反的，定义于所用函数体之外的对象其地址固定不变，能用来初始化constexpr指针
* 允许函数定义一类有效范围超出函数本身的变量，这类变量和定义在函数体之外的变量一样也有固定地址。因此constexpr引用能绑定在这样的变量上，constexpr指针也能指向这样的变量
#### 指针和constexpr
* 限定符constexpr只对指针有效，与指针所指的对象无关
```C++{.line-numbers}
const int *p = nullptr;//p是一个指向整型常量的指针
constexpr int* q = nullptr;//q是一个指向整型的常量指针
```
* constexpr把它所定义的对象置为了顶层const
## 2.5 处理类型
### 2.5.1 类型别名
* 关键字typedef
* 别名声明：把等号左侧的名字规定成等号右侧类型的别名
    ```C++
    using SI = sales_item;
    ```
#### 指针、常量和类型别名
* Note： const pstring 是指向char的常量指针，而非指向常量字符的指针
    ```C++ {.line-numbers}
    typedef char *pstring;
    const pstring cstr = 0;
    const pstring *ps;
    ```
### 2.5.2 auto类型说明符
* auto定义的变量必须有初始值
* 也可以在一条语句中声明多个变量，但该语句中的所有变量的初始基本数据类型必须一样
#### 复合类型、常量和auto
* 编译器会适当的改变结果类型使其更符合初始化规则
* 用引用类型初始化auto变量时，会以引用对象的类型作为auto的类型
* auto一般会忽略掉顶层const，保留底层const。如果希望推断出的auto类型是一个顶层const，需要明确指出
```C++{.numbers}
const auto f = ci;
```
* 设置一个类型为auto的引用时，初始值中的顶层常量属性仍然保留。如果我们给初始值绑定一个引用，则此时的常量就不是顶层常量了。
### 2.5.3 decltype 指示符
* 选择并返回操作数的数据类型，编译器分析表达式并得到他的类型，却不实际计算表达式的值
* 如果decltype使用的表达式是一个变量，则返回该变量的类型（包括顶层const和引用在内）
#### decltype和引用
* 如果表达式计算结果是引用，必须初始化
* 如果表达式的内容是解引用操作，则decltype将得到引用类型
* 对于decltype所用的表达式来说，如果变量名加上了一层括号，则得到的类型与不加括号时会有不同。具体表现为：decltype((variable))的结果永远是引用，而decltype(variable)的结果只有当variable本身就是一个引用时才是引用
* 变量是一种可以作为赋值语句左值的特殊表达式
## 2.6 自定义数据结构
### 2.6.1 定义Sales_data类型
### 2.6.2 使用Sales_data类
### 2.6.3 编写自己的头文件
* 头文件中通常包含那些只能被定义一次的实体，如类、const、和constexpr变量
* 头文件一旦改变，相关的源文件必须重新编译以获取更新过的声明
#### 预处理器概述
* 头文件保护符
* 预处理变量无视C++语言中关于作用域的规则
* 一般把预处理变量的名字全部大写
# 第三章 字符串、向量和数组
## 3.1 命名空间的using声明
### 每个名字都需要独立的using声明
### 头文件不应包含using声明
## 3.2 标准库类型string
* C++标准一方面对库类型所提供的操作做出了详细规定，另一方面也对库的实现者做出一些性能上的需求。因此，标准库类型对于一般应用场合来说有足够的效率。
### 3.2.1 定义和初始化string对象
```C++
string s4(10,'c');//s4内容为cccccccccc
```
#### 直接初始化和拷贝初始化
* 使用等号初始化变量，实际上执行的是拷贝初始化；不使用等号则是直接初始化
* 当初始值只有一个时，使用直接初始化或拷贝初始化都行。初始化要用到的值有多个，一般来说只能使用直接初始化的方式
### 3.2.2 string对象上的操作
* <,<=,>,>= 对字母的大小写是敏感的
#### 读写string对象
* 读标准输入的时候，string对象会自动忽略开头的空白（空格符、换行符、制表符等），从第一个真正的字符开始读起，直到遇见下一处空白为止。
#### 读取未知数量的string对象
```C++
while(cin >> word)//在读取时检测流的情况
```
#### 使用getline读取一整行
* 直到遇到换行符为止，**此时换行符也被读进来了**
* 读进来的内容需要存到string对象中 **不存换行符**
* getline也会返回它的流参数
#### string的empty和size操作
#### string::size_type类型
* 它是一个无符号类型的值，而且能足够存放下任何string对象的大小
* 如果一条表达式中已经有了size（）函数就不要再使用int了，这样可以避免混用int和unsigned int可能带来的问题
#### 比较string对象
#### 为string对象赋值
#### 两个string对象相加
* 连接两string
* 支持 +=
#### 字面值和string对象相加
* 当把string对象和字符字面值及字符串字面值混在一条语句中使用时，必须确保每个加法运算符（+）的两侧的运算对象至少有一个是string
* C++语言中的字符串字面值并不是标准库类型string的对象
### 3.2.3 处理string对象中的字符
* cctype头文件 定义了一组标准库文件 判断每个字符的特性
#### 处理每个字符？使用基于范围的for语句
* 范围for 遍历给定序列中的每个元素
```C++
for(declaration : expression)
    statement;
```
* expression部分表示一个序列，declaration表示的是一个属于序列中的变量
#### 使用范围for语句改变字符串中的字符
* 如果想要改变string对象中字符的值，必须把循环变量定义成引用类型
#### 只处理一部分字符？
* 两种方式：下标 或 迭代器
#### 使用下标进行迭代
* 一种简便易行的方式：总是设下标的类型为string::size_type，因为此类型是无符号数，可以确保下标不会小于0，此时只需要保证下标小于size()的值就可以了
#### 使用下标执行随机访问
## 3.3 标准库类型vector
* 编译器根据模板创建类或函数的过程称为**实例化**
* 引用不是对象，不存在包含引用的vector
### 3.3.1 定义和初始化vector对象
#### 列表初始化vector对象
* 初始化例外情况
    * 使用拷贝初始化时，只能提供一个初始值
    * 如果提供的是一个类内初始值，则只能使用拷贝初始化或使用花括号的形式初始化
    * 如果提供的是初始元素值的列表，则只能把初始值都放在花括号里进行列表初始化，而不能放在圆括号里
    ```C++
    vector<string> v1{"a","an","the"};
    ```
#### 创建指定数量的元素
#### 值初始化
* 两个要求
    * 有些类要求必须明确地提供初始值，如果vector对象中元素的类型不支持默认初始化，无法提供初始的元素值
    * 如果只提供了元素的数量而没有设定初始值，只能使用直接初始化
#### 列表初始值还是元素数量？
* 如果用了花括号，可以表述成我们想列表初始化该vector对象，初始化过程中会尽可能把花括号内的值当成是元素初始值的列表来处理，只有实在无法执行列表初始化时才会考虑其他初始化方式，才会用这样的值来**构造**vector对象了
### 3.3.2 向vector对象中添加元素
* 直接初始化的方式适用于三种情况：
    * 初始值已知且数量较少
    * 初始值是另一个vector对象的副本
    * 所有元素的初始值一样
#### 向vector对象添加元素蕴含的编程假定
* 如果循环体内部包含有向vector对象添加元素的语句，则不能使用范围for循环
* 范围for语句体内不应改变其所遍历序列的大小
### 3.3.3 其他vector操作
* 要使用size_type，需首先指定它是由哪种类型定义的
    * vector<int>::size_type
#### 计算vector内对象的索引
#### 不能用下标形式添加元素
* vector对象以及string对象的下标运算符可用于访问已存在的元素，而不能用于添加元素
* 确保下标合法的一种有效手段就是尽可能使用范围for语句
## 3.4 迭代器介绍
* 有效的迭代器或者指向某个元素，或者指向容器中尾元素的下一位置
### 3.4.1 使用迭代器
* end成员返回指向容器尾元素的下一位置的迭代器
#### 迭代器运算符
#### 将迭代器从一个元素移动到另外一个元素
* 因为end返回的迭代器并不实际指示某个元素，所以不能对其进行递增或解引用的操作
#### 迭代器类型
* iterator | const_iterator
* 如果vector对象或string对象是一个常量，只能使用const_iterator
#### begin和end运算符
* cbegin、cend不论vector对象本身是否为常量，返回值都是const_iterator
#### 结合解引用和成员访问操作
#### 某些对vector对象的操作会使迭代器失效
* 任何一种可能改变vector对象容量的操作，都会使vector对象的迭代器失效
* 但凡是使用了迭代器的循环体，都不要向迭代器所属的容器添加元素
### 3.4.2 迭代器运算
#### 迭代器的算术运算 
* 迭代器相减结果类型为名为difference_type的带符号整数
#### 使用迭代器计算
## 3.5 数组
### 3.5.1 定义和初始化内置数组
* 数组的维度必须是一个常量表达式
* 定义数组时必须指定数组的类型，不允许用auto关键字由auto关键字由初始值列表推断类型
* 不存在引用的数组
#### 显式初始化数组元素
* 如果维度比提供的初始值数量大，则用提供的初始值初始化靠前的元素，剩下的元素被初始化成默认值
#### 字符数组的特殊性
* 有一种额外的初始化形式，可以用字符串字面值对数组进行初始化，要注意字符串字面值结尾处还有一个空字符
#### 不允许拷贝和赋值
#### 理解复杂的数组声明
```C++
int (*Parray)[10] = &arr;//Parray指向一个含有10个整数的数组
int (&arrRef)[10] = arr;//arrRef引用一个含有10个整数的数组
```
### 3.5.2 访问数组元素
* 在使用数组下标的时候，通常将其定义为size_t类型（机器相关的无符号类型，被设计的足够大以便能表示内存中任意对象的大小） 在cstddef文件中定义
#### 检查下标的值
### 3.5.3 指针和数组
* 使用数组的时候，编译器一般把它转换成指针
* 当使用一个数组作为一个auto变量的初始值时，推断得到的类型是指针而不是数组
* 当使用decltyoe关键字时，返回的类型是数组
#### 指针也是迭代器
#### 标准库函数begin和end
* 两个函数，数组作为参数传入，定义在iterator头文件中
#### 指针运算
* 两个指针相减的结果类型是一种名为ptrdiff_t的标准库类型，带符号
* 如果p是空指针，允许给p加上或减去一个值为0的整型常量表达式。
* 两个空指针也允许彼此相减，结果为0
#### 解引用和指针运算的交互
#### 下标和指针
* 标准库类型限定使用的下标必须是无符号类型，但内置的下标没有这个要求（不是无符号类型），可以处理负值
### 3.5.4 C风格字符串
* C风格字符串不是一种类型，而是为了表达和使用字符串而形成的一种约定俗成的写法
#### C标准String函数
#### 比较字符串
#### 目标字符串的大小由调用者指定
### 3.5.5 与旧代码的接口
#### 混用string对象和C风格字符串
* 任何出现字符串字面值的地方都可以用以空字符结束的字符数组来替代
#### 使用数组初始化vector对象
```C++
int int_arr[] = {0,1,2,3,4,5};
vector<int> ivec(begin(int_arr),end(int_arr));
vector<int> subVec(int_arr + 1,int_arr + 4);
```
## 3.6 多维数组
#### 多维数组的初始化
#### 多维数组的下标引用
#### 使用范围for语句处理多维数组
* 要使用范围for语句处理多维数组，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型
#### 指针和多维数组
* 多维数组实质上是数组的数组
#### 类型别名简化多维数组的指针
# 第4章 表达式
## 4.1 基础
### 4.1.1 基本概念
#### 组合运算符和运算对象
#### 运算对象转换
* 小整数类型通常会被提升成较大的整数类型
#### 重载运算符
* 重载运算符时，其包括运算对象的类型和返回值的类型，都是由该运算符定义的；但是运算对象的个数、运算符的优先级和结合律都是无法改变的
#### 左值和右值
* 当一个对象被用作右值的时候，用的是对象的值（内容），当对象被用作左值的时候，用的是对象的身份（在内存中的位置）
* 一个重要的原则：在需要右值的地方可以用左值来代替，但是不能把右值当成左值使用
* 使用关键字decltype时候，左值和右值也会有不同。如果表达式的求值结果是左值，decltype得到一个引用类型。
### 4.1.2 优先级与结合律
#### 括号无视优先级与结合律
#### 优先级与结合律有何影响
### 4.1.3 求值顺序
#### 求值顺序、优先级、结合律
* 运算对象的求值顺序与优先级和结合律无关
* 拿不准运算顺序的时候，最好用括号来强制让表达式的组合关系符合程序逻辑的要求
* 如果改变了某个运算对象的值，在表达式的其它地方不要再使用这个运算对象
## 4.2 算术运算符
 ```C++
 bool b = true;
 bool b2 = -b;//b2依然为true
 ```
* C++11规定商一律向0取整
* 除了-m导致溢出的特殊情况，其他时候(-m)/n和m/(-n)都等于-(m/n)，m%(-n)等于m%n，(-m)%n等于-(m%n)
## 4.3 逻辑和关系运算符
#### 逻辑与和逻辑或运算符
* 短路求值
    * 对于逻辑与运算符来说，当且仅当左侧运算对象为真时才对右侧运算对象求值
    * 对于逻辑或运算符来说，当且仅当左侧运算对象为假时才对右侧运算对象求值
* 声明成引用类型可以避免对元素的拷贝
#### 逻辑非运算符
#### 关系运算符
#### 相等性测试与布尔字面值
* 进行比较运算时除非比较的对象是布尔类型，否则不要使用布尔字面值true和false作为运算对象
## 4.4 赋值运算符
* 在使用初始值列表作为赋值语句的右侧运算对象时，如果左侧运算对象是内置类型，那么初始值参数列表最多只能包含一个值，而且该值即使转换的话其所占空间也不应该大于目标类型的空间
#### 赋值运算满足右结合律
```C++
int ival,jval;
ival = jval = 0;//正确，都被赋值为0
```
#### 赋值运算优先级较低
* 赋值运算符的优先级低于关系运算符的优先级
#### 切勿混淆相等运算符和赋值运算符
#### 复合赋值运算符
## 4.5 递增和递减运算符
* 必须作用于左值运算对象。前置版本将对象本身作为左值返回，后置版本则将对象原始值的副本作为右值返回
* 除非必须，否则不用递增递减运算符的后置版本
#### 在一条语句中混用解引用和递增运算符
#### 运算对象可按任意顺序求值
## 4.6 成员访问运算符
## 4.7 条件运算符
* 当条件运算符的两个表达式都是左值或者能转换成同一种左值类型时，运算的结果是左值；否则运算的结果是右值
#### 嵌套条件运算符
* 随着条件运算嵌套层数的增加，代码的可读性急剧下降。最好别超过两到三层
#### 在输出表达式中使用条件运算符
## 4.8 位运算符
* 关于符号位如何处理没有明确的规定，所以强烈建议仅将位运算符用于处理无符号类型
#### 移位运算符
* 右移运算符的行为依赖于其左侧运算对象的类型，如果该运算对象是无符号类型，在左侧插入值为0的二进制位；如果该运算对象是带符号类型，在左侧插入符号位的副本或值为0的二进制位，如何选择视具体环境而定
#### 位求反运算符
#### 位与、位或、位异或运算符
* 对于位异或运算符来说，如果两个运算对象的对应位置有且只有一个为1则运算结果中该位为1，否则为0
#### 使用位运算符
#### 移位运算符（又叫IO运算符）满足左结合律
## 4.9 sizeof运算符
* 所得值的类型是size_t
* 在sizeof的运算对象中解引用一个无效指针仍然是一种安全的行为，因为指针实际上并没有被真正使用。sizeof不需要真的解引用也能知道它所指对象的类型
* 允许我们使用作用域运算符来获取类成员的大小
```C++
sizeof Sales_data::revenue;
```
* sizeof运算不会把数组转换成指针来处理
* sizeof的返回值是一个常量表达式，可以用其声明数组的维度
## 4.10 逗号运算符
* 首先对左侧的表达式求值，然后将求值结果丢弃掉，逗号运算符的真正结果是右侧表达式的值
## 4.11 类型转换
* 隐式转换：自动执行，无需程序员介入
#### 何时发生隐式类型转换
* 在大多数表达式中，比int类型小的整数值三个首先提升为较大的整数值
### 4.11.1 算术转换
#### 整型提升
* 转换后的类型要能容纳原类型所有可能的值
#### 无符号类型的运算对象
* 如果一个运算对象是无符号类型，另外一个运算对象是带符号类型，而且其中的无符号类型不小于带符号类型，那么带符号的运算对象转换成无符号的
#### 理解算术转换
### 4.11.2 其他隐式类型转换
* 数组转换成指针
    * 当数组被用作decltype关键字的参数，或者作为取地址符、sizeof及typeid等运算符的运算对象时，上述转换不会发生
### 4.11.3 现实转换
#### 命名的强制类型转换
* static_cast：任何具有明确定义的类型转换，只要不包含底层const，都可以使用
* const_cast：只能改变运算对象的底层const
* reinterpret_cast：通常为运算对象的位模式提供较低层次上的重新解释7
#### 旧式的强制类型转换
## 4.12 运算符优先级表
# 第五章 语句
## 5.1 简单语句
#### 空语句
#### 别漏写分号，也别多写分号
* 多余的空语句并非总是无害的
#### 复合语句（块）
## 5.2 语句作用域
## 5.3 条件语句
### 5.3.1 if语句
#### 使用if else语句
#### 嵌套if语句
#### 注意使用花括号
#### 悬垂else
* else与离它最近的尚未匹配的if匹配
#### 使用花括号控制执行路径
### 5.3.2 switch语句
* case标签：case关键字和它对应的值
* case标签必须是整型常量表达式
#### switch内部的控制流
#### 漏写break容易引发缺陷
#### default标签
* 标签不应该孤零零的出现，它后面必须跟上一条语句或者另外一个case标签
#### switch内部的变量定义
* 如果在某处一个带有初值的变量位于作用域之外，在另一处该变量位于作用域之内，则从前一处跳转到后一处的行为是非法行为
* 不允许跨过变量的初始化语句直接跳转到该变量作用域内的另一个位置
## 5.4 迭代语句
### 5.4.1 while语句
* 定义在while条件部分或者while循环体内的变量每次迭代都经历从创建到销毁的过程
#### 使用while循环
* 不确定要迭代多少次时/想在循环结束后访问循环控制变量
### 5.4.2 传统的for语句
#### 传统for循环的执行流程
#### for语句头中的多重定义
* 只能有一条声明语句，因此所有变量的基础类型必须相同
#### 省略for语句头的某些部分
* 省略condition的效果等价于在条件部分写了一个true
### 5.4.3 范围for语句
* 如果要对序列中的元素执行写操作，循环变量必须声明成引用类型
* 在范围for语句中预存了end()的值，一旦在序列中添加或删除元素，end函数的值可能就变得无效了
### 5.4.4 do while语句
* 先执行循环体，后检查条件
* condition使用的变量必须定义在循环体之外
## 5.5 跳转语句
### 5.5.1 break语句
* 只能出现在迭代语句或者switch语句内部
### 5.5.2 continue语句
### 5.5.3 goto语句
## 5.6 try语句块和异常处理
* throw表达式：表示遇到了无法处理的问题
* tyr语句块：以关键字try开始，并以一个或多个catch子句结束。try语句块中代码抛出的异常通常会被某个catch子句处理
* 一套异常类：在throw表达式和相关catch子句之间传递异常的具体信息
### 5.6.1 throw表达式
* 抛出异常将终止当前的函数，并把控制权转移给能处理该异常的代码
### 5.6.2 try语句块
* 当选中了某个catch子句处理异常之后，执行与之对应的块，catch一旦完成，程序跳转到try语句块最后一个catch子句之后的那条语句继续执行
#### 编写处理代码
#### 函数在寻找处理代码的过程中退出
* 如果一段程序没有调用try语句块且发生了异常，系统会调用terminate函数并终止当前程序的执行
* 异常安全的代码：在异常发生期间正确执行了“清理”工作的程序
### 5.6.3 标准异常
* 异常类
    * exception 只报告异常的发生，不提供任何额外信息
    * stdexcept头文件定义几种常用的异常类
    * new头文件定义了bad_alloc异常类型
    * type_info头文件定义了bad_cast异常类型
* 我们只能以默认初始化的方式初始化exception、bad_alloc和bad_cast对象，不允许为这些对象提供初始值
* 除去上面这些异常外的其他类型异常，应该使用string对象或C风格字符串初始化这些类型的对象，但是不允许使用默认初始化的方式。当创建此类对象时必须提供初始值，初始值含有错误的相关信息
* 对于无初始值的异常类型来说，what返回的内容由编译器决定
# 第6章 函数
## 6.1 函数基础
#### 编写函数
#### 调用函数
* 函数的调用完成两项工作：一是用实参初始化函数对应的形参，二是将控制权转移给被调用函数
#### 形参和实参
#### 函数的形参列表
* 可以使用void表示函数没有形参
#### 函数返回类型
* 函数的返回类型不能是数组类型或函数类型，但可以是指向数组或函数的指针
### 6.1.1 局部对象
* 名字的作用域时程序文本的一部分，名字在其中可见
* 对象的生命周期是程序执行过程中该对象存在的一段时间
* 局部变量会隐藏在外层作用域中同名的其他所有声明中
#### 自动对象
* 只存在于块执行期间
#### 局部静态对象
* 在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁，在此期间即使对象所在的函数结束执行也不会对它有影响
* 如果局部静态变量没有显示的初始值，它将被执行值初始化，内置类型的局部静态变量初始化为0
### 6.1.2 函数声明
* 函数声明也称为函数原型
#### 在头文件中进行函数声明
### 6.1.3 分离式编译
#### 编译和链接多个源文件
## 6.2 参数传递
### 6.2.1 传值参数
* 函数对形参做的所有操作都不会影响实参
#### 指针形参
### 6.2.2 传引用参数
* 通过使用引用形参，允许函数改变一个或多个实参的值
#### 使用引用避免拷贝
* 当函数无须修改引用形参的值时最好使用常量引用
#### 使用引用形参返回额外信息
### 6.2.3 const形参和实参
* 当用实参初始化形参时会忽略掉顶层const
* 由于上面这个原因，下面的两个函数定义不算是函数重载
```C++
void fcn(const int i) {/*fcn能够读取i，但是不能向i写值*/}
void fcn(int i){/*...*/}
```
#### 指针或引用形参与const
* 我们可以使用非常量初始化一个底层const对象，但是反过来不行
* 不能把普通引用绑定到const对象和字面值上
#### 尽量使用常量引用
### 6.2.4 数组形参
* 两个性质：
    * 不允许拷贝数组——>无法以值传递的方式使用数组参数
    * 使用数组时通常会将其转换为指针
* 数组的大小对函数的调用没有影响
### 管理数组实参的三种方式
#### 使用标记指定数组长度
* 适用于有明显结束标记且该标记不会与普通数据混淆的情况
#### 使用标准库规范
* 传递数组首元素和尾后元素的指针
#### 显示传递一个表示数组大小的形参
#### 数组形参和const
* 只有当函数确实要改变元素值的时候才把形参定义成指向非常量的指针
#### 数组引用形参
```C++
f(int (&arr)[10]) //arr是具有10个整数的整型数组的引用
f(int &arr[10]) //arr是引用的数组
```
#### 传递多维数组
* 数组首元素本身就是一个数组，所以传参的时候传的是一个指向数组的指针
### 6.2.5 main：处理命令行选项
* main函数有两个参数，第二个形参argv是一个数组，它的元素是指向C风格字符串的指针；第一个参数argc表示数组中字符串的数量
* 当使用argv中的实参时，一定要记得可选的实参从argv[1]开始；argv[0]保存程序的名字，而非用户输入
### 6.2.6 含有可变形参的函数
#### initializer_list形参
* 如果函数的实参数量未知但是全部实参的类型都相同，我们可以使用initializer_list的形参 用于表示某种特定类型的值的数组
* initializer_list对象中的元素永远是常量值，我们无法改变其元素的值
* 拷贝或赋值一个initializer_list对象不会拷贝列表中的元素；拷贝后，原始列表和副本共享元素
* 含有initializer_list形参的函数也可以同时拥有其他形参
#### 省略符形参
* 省略符形参应该仅仅用于C和C++通用的类型。特别应该注意的是，大多数类类型的对象在传递给省略符形参时都无法正确拷贝
* 省略符形参所对应的实参无须类型检查
## 6.3 返回类型和return语句
### 6.3.1 无返回值函数
### 6.3.2 有返回值函数
#### 值是如何被返回的
* 返回的值用于初始化调用点的一个临时量，该临时量就是函数调用的结果
#### 不要返回局部对象的引用或指针
* 一旦函数完成，局部对象被释放，指针和引用对会指向不存在的对象
#### 返回类类型的函数和调用运算符
#### 引用返回左值
* 调用一个返回引用的函数得到左值，其他返回类型得到右值
* 我们能为返回类型是非常量引用的函数的结果赋值
#### 列表初始化返回值
* 如果函数返回的是内置类型，则花括号包围的列表最多包含一个值，而且该值所占空间不应该大于目标类型的空间。如果函数返回的是类类型，由类本身定义初始值如何使用
#### 主函数main的返回值
* 如果控制到达了main函数的结尾处而且没有return语句，编译器将隐式地插入一条返回0的return语句
* cstdlib中定义了两个预处理变量表示程序执行成功与失败 EXIT_FAILURE/EXIT_SUCCESS
* 预处理变量既不能在前面加上std::，也不能在using声明中出现
#### 递归
* main函数不能调用它自己
### 6.3.3 返回数组指针
* 因为数组不能拷贝，所以函数不能返回数组
```C++
typedef int arrT[10];
using arrT = int[10];
arrT* func(int i);
```
* arrT是含有10个整数的数组的别名
#### 声明一个返回数组指针的函数
* 声明格式：
```C++
Type (*function(parameter_list))[dimension]
```
#### 使用尾置返回类型
```C++
auto func(int i) -> int(*)[10];
```
#### 使用decltype
* decltype并不负责把数组类型转换成相应的指针
## 6.4 函数重载
* main函数不能重载
#### 定义重载函数
* 对于重载的函数来说，他们应该在形参数量或形参类型上有所不同
* 不允许两个函数除了返回类型外其他所有的要素都相同
#### 判断两个形参的类型是否相异
#### 重载和const形参
* 一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来
* 如果形参是某种类型的指针或引用，则通过区分其指向的是常量对象还是非常量对象可以实现函数重载，此时的const是底层的
* 当我们传递一个非常量对象或者指向非常量对象的指针时，编译器会优先选用非常量版本的函数
#### const_cast和重载
#### 调用重载的函数
* 函数匹配 == 重载确定：一个过程 把函数调用与一组重载函数中的某一个关联起来
* 当调用重载函数时有三种可能的结果：
    * 编译器找到一个与实参最佳匹配的函数，并生成调用该函数的代码
    * 找不到任何一个函数与调用的实参匹配，此时编译器发出无匹配的错误
    * 有多于一个函数可以匹配，但是每一个都不是明显的最佳选择。此时也将发生错误，称为二义性调用
### 6.4.1 重载与作用域
* 在不同的作用域中无法重载函数名
* 在C++语言中，名字查找发生在类型检查之前
## 6.5 特殊用途语言特性
### 6.5.1 默认实参
* 一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值
#### 使用默认实参调用函数
* 默认实参只负责填补函数调用缺少的尾部实参
* 要合理设置形参的顺序
#### 默认实参声明
#### 默认实参初始值
* 局部变量不能作为默认实参。除此之外只要表达式的类型能转换成形参所需要的类型，该表达式就能作为默认实参
* 用作默认实参在函数声明所在的作用域内解析，而求值过程发生在函数调用时
### 6.5.2 内联函数和constexpr函数
#### 内联函数可以避免函数调用的开销
* 关键字 inline
#### constexpr函数
* 能用于常量表达式的函数
* 函数的返回类型以及所有形参的类型都得是字面值类型，而且函数体中必须有且只有一条return语句
* constexpr函数被隐式地指定为內联函数
* constexpr函数不一定返回常量表达式
#### 把内联函数和constexpr函数放在头文件中（定义）
* 可以在程序中多次定义，但对于某个函数来说，它的多个定义必须完全一致